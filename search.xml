<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《Effective Objective-C》读后感1-8]]></title>
    <url>%2F2018%2F05%2F02%2F%E3%80%8AEffective-Objective-C%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F1-8%2F</url>
    <content type="text"><![CDATA[1. Familiarize Yourself with Objective-C’s RootsOC是C的完全超集，其中一个很大的区别是C语言为函数调用，而OC为消息传递。这其中一个主要的区别在于消息传递会在运行时决定哪些消息被发送到哪些对象，而函数调用在编译时就确定了这些事情。也正因为此，OC的运行时就必须包含所有数据和函数。也正因为这个，只要运行时（系统）升级之后，使用OC的App也就自动地享有了这些升级带来的优化。而更注重编译时的语言，则需要重新编译之后才能享有这些优化。 OC的一个对象数据如： NSString* string = @ &quot;abc&quot;; 它的内存情况其实是一个在Stack中开辟的一个指针空间（在32位的设备上是4个bytes，在64位上是8个bytes）指向了一个在Heap上开辟的存abc这个字符串的空间。 2. Minimize Importing Headers in Headers尽量使用@class来避免在头文件中import 另一个类的头文件 3. Prefer Literal Syntax over the Equivalent Methods尽量使用类似如下的代码： 123NSNumber *intNumber = @1;NSArray *animals = @[@&quot;cat&quot;, @&quot;dog&quot;, @&quot;mouse&quot;, @&quot;badger&quot;];NSDictionary *dic = @&#123;@&quot;key1&quot;: @&quot;value1&quot;, @&quot;key2&quot;: @&quot;value2&quot;&#125;; 4. Prefer Typed Constants to Preprocessor #define尽量少用#define来定义常量，而是使用如下的方式定义常量：static const NSTimeInerval kAnimationDuration = 0.3;这种方式保证了为编译器提供了类型检查（新版本的Xcode似乎在#define中也能做类型检测）。另外，const保证了定义的是一个常量。 static保证了这个常量是在一个.m中local的，不会和其他文件中相同的名字的变量产生冲突，因为本质上，如果加了static关键字后编译器就会在编译的时候想#define一样，将定义的内容直接展开到对应的代码中。对于NSNotificaiton中使用的name，建议使用的定义方式如下：extern NSString *const XXXXDidFinishLoginNotification; 5. Use Enumerations for States, Options, and Status Codes在switch case代码段中，不要去写default，这样的话，当你在枚举中添加新的元素的时候，编译器就给出提示，因为代码中并没有将所有枚举中的情形都覆盖全。 6. Understand Properties7. Access Instance Variables Primarily Directly When Accessing Them Internally当在类的内部访问成员变量的时候，直接访问成员变量和使用property访问有几点区别：直接访问变量可以直接获得希望获得的数据或直接修改对应的值，而使用property访问将会出发消息传递的机制，使得可能出现因运行时而产生的意外，因此，从某种程度上说，直接访问将会更加“安全”。直接访问将会绕过变量的内存管理机制。（似乎最新的版本中并不会绕过）直接访问将不会触发KVO通知。（存疑）使用property会更加方便调试，可以在setter和getter中加断点。（直接访问的话，watch似乎也能解决一部分问题） 类的内部直接访问成员变量有几个需要注意的点：在初始化函数中给成员变量赋值的时候，使用直接访问的方式进行赋值：子类可能会重载setter函数，从而产生意外的情况。对于一些Lazy初始化的变量，如果使用直接访问的话，可能导致这个变量无法被正常初始化。 8. Understand Object Equality]]></content>
      <categories>
        <category>Effective Objective-C</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC可变参数函数]]></title>
    <url>%2F2017%2F07%2F20%2FOC%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[今天实现一个功能的时候需要用到可变参数，突然发现这些平时不常用的小技巧自己掌握地还不是很好，基本上用到了都要去网上搜，与其去其他地方找，还不如自己把这些小技巧都收集起来，也方便自己以后使用。于是有了这个Tag的开篇。 话不多说，直接上代码 123456789101112131415161718192021+(instancetype)tupleWithObjects:(id)object, ...NS_REQUIRES_NIL_TERMINATION&#123; Tuple *tuple = [[Tuple alloc] init]; NSMutableArray *objects = [[NSMutableArray alloc] init]; va_list argList; if(object != nil) &#123; [objects addObject:object]; va_start(argList, object); id arg; while((arg = va_arg(argList, id))) &#123; [objects addObject:arg]; &#125; va_end(argList); [tuple.objects addObjectsFromArray:objects]; &#125; return tuple;&#125; 值得注意的是，在调用可变参数的函数时，记得要在最后一个参数后加上nil，否则在调用arg=va_arg(argList, id)时会发生Crash。]]></content>
      <tags>
        <tag>Objective-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈iOS签名机制]]></title>
    <url>%2F2017%2F01%2F23%2F%E6%B5%85%E8%B0%88iOS%E7%AD%BE%E5%90%8D%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[“Users appreciate code signing.” –《Apple Developer Library:About Code Signing》 P.S. 苹果已经无耻地在最新的文档里删掉了这行描述，想来苹果估计也发现了code signing并没有被users appreciate，对于普通用户而言，根本不需要关注code signing，而对于开发者而言，code signing简直就是噩梦~！ 下面我粗略谈一谈对于code signing的一些浅显的认识，其中很多部分是源于《Apple Developer Library:About Code Signing》 补充知识因为Code Signing机制涉及到加密技术，下面简略说明一下常用的加密技术，如果已经非常了解相关知识，请略过这部分内容。 对称加密和非对称加密：顾名思义，对称加密就是用来加密和解密的密钥是同一个，平常在项目里常用到的AES就是典型的对称加密。非对称加密指的就是加密和解密的密钥是不用的，有一把公钥，一把私钥，如果使用公钥加密，就得用私钥进行解密，而使用私钥加密就得用公钥进行解密，如常用的RSA就是非对称加密。 优缺点：对称加密使用相同的密钥进行加解密，所以效率非常高，但是由于解密一方也必须知道密钥，那么密钥势必就得通过某种途径进行传输，这就造成了密钥不安全的情况。非对称加密正好和对称加密相反，它的特点就是，加解密效率较低，但是安全性高。所以通常的做法是将两者结合使用，即使用对称加密的方式对正文进行加密，使用非对称加密的方式对密钥进行加密。 数字签名: 数字签名技术类似现实生活中的印章和签名，主要的作用是保证内容没有被修改，以及签名方无法进行抵赖。数字签名技术简单来讲就是发送方采用特定的算法产生正文的摘要，然后使用发送方的私钥进行加密，接收方收到数字签名后，使用发送方的公钥进行解密，然后比对正文摘要，如果相同，表示该数字签名是合法的，否则就是有问题的。 数字证书: 数字证书是由权威机构－－CA证书授权（Certificate Authority）中心发行的，能提供在Internet上进行身份验证的一种权威性电子文档，人们可以在互联网交往中用它来证明自己的身份和识别对方的身份。 Code Signing的好处书归正题，下面我们开始讲讲Code Signing的好处。 保证代码不会被篡改 明确代码的来源，Code Signing可以描述一个App是由谁进行签名的：Apple或者特定的开发者，或者其他一些组织和机构。 决定代码是否可以继续访问特定的数据，因为iOS的隐私管理机制，App在第一次访问如相册，通讯录等数据时会询问用户是否允许，一旦允许后后续再对这些数据进行访问的时候就不再进行询问，但是如果App的版本进行了更新，对于系统而言，一个新的版本其实就是一个新的App，系统就是通过Code Signing来判断这个版本是否可以继续访问这些隐私数据。 Code Signing不能保证的 无法保证经过签名的代码是没有安全问题的。 无法保证App是否会在运行过程中加载不安全，没经过签名的代码。 无法提供数字产权保护(DRM)和copy protection technology iOS Code Signing工作原理iOS的签名设置简直就是一项不能更加坑爹的工作了，当你潇潇洒洒写完一大段代码后，因为签名设置的问题被Xcode各种报错的时候，心中必然会有一万只草泥马奔过。下面大致来聊一聊iOS整个签名过程。 组成 CertificateSigningRequest.certSigningRequest，这个文件是在Certificate Assistant中生成的，本质上这个文件就是一个申请书，里面描述了申请人的信息，申请人的公钥，还有摘要文件和公钥的加密算法。一般情况下开发者是不需要关心这个文件的（除非你还是你们公司ADP的管理人员）可以使用openssl asn1parse -i -in CertificateSigningRequest.certSigningRequest查看CSR文件。 Certificate文件，使用上面的CSR能够在Apple Developer Member Center中生成对应的certificate文件，可以使用openssl x509 -inform der -in ios_development.cer -noout -text对生成的.cer文件进行查看。双击这个.cer文件之后就会在Keychain中添加一个certificate文件，如果这时候你有刚才生成CSR的私钥，那么你的certificate就可以使用了，否则的话就需要导入对应的私钥。 mobileprovision文件，严格来说mobileprovision文件已经不属于签名的范畴了，它其实是一个描述文件，用来描述app所使用的某些服务是被苹果认可的，比如APN推送服务以及限制app的装机规模。如果没有这个玩意，每个app开发者就可以自己签app然后放到自己的网站上供用户下载，谁还提交到AppStore，审批时间又长，还可能各种被拒。使用security cms -D -i命令可以查看一个mobileprovision文件的内容，这个文件主要描述了下面这些内容： 被描述的App的信息，AppIDName， App Bundle ID等。 使用哪些Certificate，所以如果你有一个certificate,有一个和certificate匹配的私钥，也有一个mobileprovision文件，但是你的mobileprovision文件和certificate是不匹配的，那么还是无法真机调试。功能授权列表，用来描述这个App能够使用哪些功能，如APN，IAP等。这个描述文件允许的Device UDID列表，只有在这个列表中的设备，才可以安装这个App。至于企业签名的描述文件，则没有ProvisionedDevices这个字段，取而代之的是一个叫ProvisionsAllDevices的字段，这个字段值为true。当然了，这个文件本身是被苹果做过签名的，所以什么自己在ProvisionedDevices下面加一个Device的UDID事情就不要多想了。 Certificate的公钥，关于这点，貌似并没有在命令的输出中体现出来，所以不要问我是怎么知道的，因为我是猜的！既然Xcode使用私钥对App进行签名，那么就一定要有一个机制将对应的公钥放到App中，这样App在运行之前才可以用公钥来对数字签名进行解密，从而认证App的合法性。而每个App编译完成后在它的content下一定有一个embedded.mobileprovision文件。而上面提到过certificate文件是有我的公钥信息的，而mobileprovision文件是一定要通过certificate文件才能生成的，我实在想不到有什么理由苹果不将公钥放到mobileprovision文件中。 过期时间等其他信息。 _CodeSignature文件夹，在每个经过签名的iOS app文件下都有一个叫_CodeSignature的文件夹，这个文件夹下有一个叫CodeResources的文本文件。其实这个文件本质上就是一个plist，其中描述的就是每个资源文件的签名信息。至于程序本身的二进制文件，签名信息应该是直接写入到这个二进制文件中的。这个文件的存在就保证了app在被签名之后，其中的任何资源发生了修改，在进行签名验证的时候都会出现问题，而导致验证不过。可以使用codesign –verify Sample.app来对app的签名进行验证，如果这个命令没有输出任何内容，那么签名验证就是通过的。 entitlement文件，当你在程序中打开如APN，Associated Domains，App Groups等功能时，Xcode会帮你自动生成一个entitlement文件，而这个文件也将会作为codesign的参数传入，如果你的entitlement文件和mobileprovision文件中描述的不一致，也会造成app安装后的校验不通过，导致app无法被正常安装。 过程 在程序完成编译后，Xcode会使用codesign，通过certificate文件下的私钥对app进行签名。可以使用codesign -vv -d Example.app查看app的签名信息。 校验BundleID等信息 使用embedded.mobileprovision下的公钥来进行程序是否被篡改的校验。 使用embedded.mobileprovision和entitlement文件校验功能授权列表。 上面的过程中的顺序不一定是真正校验的顺序，上面列举的校验步骤也不一定是完整的校验步骤，一切都是我个人的猜测。]]></content>
      <tags>
        <tag>iOS技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS项目中添加自定义宏]]></title>
    <url>%2F2016%2F12%2F13%2FiOS%E9%A1%B9%E7%9B%AE%E4%B8%AD%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%8F%2F</url>
    <content type="text"><![CDATA[最近公司的项目都切到了Git上，之前在使用SVN的时候，BuildServer在编译版本的时候会自动将SVN版本号同时打到编译出来的包中，这样我们在提交测试或者提交到ITC的时候可以由开发的同学们再Double Check一遍版本号，保证提交的版本不会有问题。但是Git上是不存在SVN版本号这样一个东西的，那么我们该如何追踪呢，下面介绍一下我想到的一个办法： 在项目配置中选中PROJECT（不是某一个Target，如果选中的是某一个Target的话，需要给为所有Target都操作一遍），点击Build Settings选项，添加User-Defined Setting，将Key设置为：IS_GIT_COMMIT，Value本地随便填。具体操作如下图： 在Build Settings搜索macros，在Preprocessor Macros中添加一项：GitCommit=&quot;@\&quot;$(IS_GIT_COMMIT)\&quot;&quot; 在项目中就可以正常使用GitCommit这个宏了: 12NSString *gitCommit = GitCommit;NSLog(@&quot;%@&quot;, gitCommit);]]></content>
      <tags>
        <tag>iOS技巧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Swift编译慢并没什么卵用的解决办法]]></title>
    <url>%2F2016%2F08%2F19%2F%E5%85%B3%E4%BA%8ESwift%E7%BC%96%E8%AF%91%E6%85%A2%E5%B9%B6%E6%B2%A1%E4%BB%80%E4%B9%88%E5%8D%B5%E7%94%A8%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[目前开发中的项目使用了Swift和OC混编的，在感慨Swift本身的强大的前提下，也不得不面对引入Swfit带来的问题，比如App包的变大，比如Xcode对于Swift的支持不如OC等等，但是，对我来讲，最坑爹的还是引入了Swfit之后编译速度慢成了狗。如果大家还没有体会过Swift的编译速度能够慢到什么程度，请义无反顾地将下面的代码加入到工程中去: 123456789101112131415161718192021222324let myCompany = [ &quot;employees&quot;: [ &quot;employee 1&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 2&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 3&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 4&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 5&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 6&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 7&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 8&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 9&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 10&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 11&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 12&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 13&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 14&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 15&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 16&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 17&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 18&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 19&quot;: [&quot;attribute&quot;: &quot;value&quot;], &quot;employee 20&quot;: [&quot;attribute&quot;: &quot;value&quot;], ]] OK, 在项目里加上上面的代码之后，如果不出什么意外的话（相信我，应该不会出什么意外的，除非你的开发机是一台超级计算机）你就可以双手离开键盘，起身出去吃饭了，如果运气好的话，你的项目应该能够在你吃完饭之后成功编译，当然了，其实我根本就没有成功编译这段代码，所以他具体要花多长时间我并不知，可能是一顿饭的时间，也可能需要天荒地老，海枯石烂 。 OK，回归正题，我们来讲一下，如何来提高Swift的编译速度，在讲如何提高Swfit的编译速度之前，我们先来将一些全局的设置，当然了，只要是对于Debug而言的，首先，在Build Settings的Debug Information Format中，见Debug得格式改为DWARF，因为我们在Debug的过程中一般是不需要这些Crash Symbol的，另外，Build Settings的Build Active Architecture Only，将Debug改为Yes，也就是说只编译当前选中的设备的架构，否则的话，编译时编译器就会将所有支持的Architecture都编一次（一般来讲现在都是armv7和arm64）。好了，讲过这些通用的设置之后，我们来看一下加入了Swift之后App编译的过程。 如果有CocoaPods的话，编译对应的.a或者framework编译xib等资源文件编译Swift文件编译.m， .cpp等文件通常情况下，耗时最长的就是编译swift文件了，而且在编译的时候不像是编译.m文件，Xcode连个进度都不给，所以给人的感觉就是卡在这步不动了。 至于为什么编swift文件会这么慢，这里就要借助编译提供的额外的信息了。还是Build Settings中，在Other Swift Flags中加入-Xfrontend -debug-time-function-bodies然后就可以在编译输出的界面看到每个函数编译花费的时间了。当然了，更加简单的方法就是加一个Xcode的插件BuildTimeAnalyzer-for-Xcode 之后就是根据编译的时间来找茬了，下面列几个特别毁三观的情况，大家自己看。 12let tableHeight = CGFloat(80 * 2 + 50 + 52 + 35) //3.1mslet tableHeight:CGFloat = 80 * 2 + 50 + 52 + 35 //1588ms 两行代码编译时间差了500多倍，三观尽毁 1234567//写法一contactInfoArray.appendContentsOf(mobileItems)contactInfoArray.appendContentsOf(telItems)contactInfoArray.appendContentsOf(faxItems)//写法二contactInfoArray.appendContentsOf(mobileItems + telItems + faxItems)写法一比写法二在编译时快了2000多ms 1234567891011121314151617181920212223242526272829303132333435//写法一if let index = localMessageIDs.indexOf(kCCAssistantMessageIDCardClaim) &#123; if index &lt; messageShowncount &#123; if let oneMessage = messageObjectArray[index] as? CCAssistantMessageType6 &#123; if oneMessage.localMessageID == kCCAssistantMessageIDCardClaim &#123; oneMessage.fetchUm03UpdateInfo() dispatch_async(dispatch_get_main_queue(), &#123; let indexStr = &quot;\(index)&quot; NSNotificationCenter.defaultCenter().postNotificationName(CCMessageAssistantDidUpdateMessagesNotification, object: nil, userInfo: [kMessageUpdateTypeModify:indexStr]) &#125;) ISSwiftInfo(&quot;Signal&quot;) dispatch_semaphore_signal(IOSemaphore) return &#125; &#125; &#125;&#125;//写法二if let index = localMessageIDs.indexOf(kCCAssistantMessageIDCardClaim) &#123; if index &lt; messageShowncount &#123; if let oneMessage = messageObjectArray[index] as? CCAssistantMessageType6 &#123; if oneMessage.localMessageID == kCCAssistantMessageIDCardClaim &#123; oneMessage.fetchUm03UpdateInfo() dispatch_async(dispatch_get_main_queue(), &#123; NSNotificationCenter.defaultCenter().postNotificationName(CCMessageAssistantDidUpdateMessagesNotification, object: nil, userInfo: [kMessageUpdateTypeModify:&quot;\(index)&quot;]) &#125;) ISSwiftInfo(&quot;Signal&quot;) dispatch_semaphore_signal(IOSemaphore) return &#125; &#125; &#125;&#125; 写法一比写法二编译时快600ms 另外，再介绍一个最大的坑，在查看函数编译时间的时候，会发现有些swift文件的getter方法或者closure会被编译几百次，成为编译速度慢的罪魁祸首，最后分析下来，原来都是lazy （Lazy关键字的解释）这个关键字搞得鬼，只要是被lazy修饰的变量，会在每个swfit文件被编译的时候都编译一次，简直就是坑爹。 好了，稍微总结一下，根本原则就是，如果希望编译速度更快，那么就在代码中更多地显示声明变量的类型啦，容器元素的类型啦等等。就是不要让编译器在编译的时候帮你去分析类型。总得来讲就是，写代码写得越爽，编译时间很可能就会变长。 最后，点一下题吧，为什么说没什么卵用的解决方法呢，首先，lazy这个关键字没法去啊，去了之后编译的时间是变短了，但是运行的效率也降低了。另外一个最最关键的原因，架不住文件多啊，每个文件几百ms，几千个文件一加就崩溃了，另外还得加上CocoaPods的编译，xib资源文件的编译，以及.m这些文件的编译。总的来讲，就是——并没什么卵子用！]]></content>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在iOS9中突破微信App跳转的限制]]></title>
    <url>%2F2016%2F01%2F26%2F%E5%9C%A8iOS9%E4%B8%AD%E7%AA%81%E7%A0%B4%E5%BE%AE%E4%BF%A1App%E8%B7%B3%E8%BD%AC%E7%9A%84%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[前言微信的普及程度相信不需要多言了，稍微回忆一下自己上一条短信是什么时候，上一条微信又是什么时候就知道了。因此通过微信传播也是绝大部分App的一个重要手段，但是在iOS7微信出的新版本，就开始不允许从微信直接跳转到对应的App中了。所谓上有政策，下有对策，各大App纷纷想出自己的解决方案，目前最最流行的就是在点击跳转到自己的App的时候出现一个蒙板，然后一个箭头指向右上角的更多按钮，然后用户从Safari打开当前网页，然后点击跳转。这个版本算是一种无奈的妥协吧，毕竟用户用起来还是有点蛋疼的。最近博主的一个Boss发现网易新闻竟然能直接从微信里打开自己的App，于是乎~这个“艰巨”的任务就落到了我的头上。中间研究的过程就不再赘述，隆重请出使用到的技术：iOS9 Universal Links！这里不禁要夸一夸网易的iOS开发同学们，看文档看得够仔细啊！附上Apple的官方文档，What’s new in iOS不知大家能否在Search那一栏中找到Universal links: Universal links let you replace custom URL schemes with standard HTTP or HTTPS links. Universal links work for all users: If users have your app installed, the link takes them directly into your app; if they don’t have your app installed, the link opens your website in Safari. To learn more about universal links, see Support Universal Links. P.S.该技术目前只能应用在iOS9中。 开搞OK，我们开搞。 首先，参照上面提到的文档，创建一个叫apple-app-site-association的json文件(请不要加上.json或者其他任何后缀名)，文件的大致内容如下: 1234567891011&#123; &quot;applinks&quot;: &#123; &quot;apps&quot;: [], &quot;details&quot;: [ &#123; &quot;appID&quot;: &quot;9JA89QQLNQ.com.apple.wwdc&quot;, &quot;paths&quot;: [ &quot;/wwdc/news/&quot;, &quot;/videos/wwdc/2015/*&quot;] &#125; ] &#125;&#125; 下面来解释一下这个json文件里的字段： apps: 目前只需要提供一个空数组就可以了，但是这个字段必须提供，不可不填。appID:appID的格式大致是这样的：TeamID.App Bundle ID,以文档中提供的例子来说，Apple出的WWDC的应用的开发者Team的Team ID为：9JA89QQLNQ，这个应用的BundleID为：com.apple.wwdc。paths:希望Safari在访问哪个路径时，跳转到对应的App，可以使用*作为通配符。 将准备好的apple-app-site-association上传到web网站的根目录下。 配置App的Entitlements file：选中App的Target，在Capabilities中打开Associated Domains 切记关联的域名需要使用applinks:作为开头。 在AppDelegate中实现对应的delegate，大致代码如下： 12345678-(BOOL)application:(UIApplication *)application continueUserActivity:(NSUserActivity *)userActivity restorationHandler:(void (^)(NSArray * _Nullable))restorationHandler&#123; if (userActivity.webpageURL != nil) &#123; &#125;&#125; userActivity中的webpageURL就是对应的从Web端跳转而来的网址，其中可以带上各种参数来供App进行不通的判断和操作。 Web页面上的JS代码大致如下： 1234567var open_app = document.getElementById(&apos;open_app&apos;);btn_open.addEventListener(&apos;click&apos;, function() &#123; open_app.src = &apos;https://www.domain.com/site/download?force=1&apos;; setTimeout(function() &#123; location.href = &apos;https://www.domain.com/site/download?force=1&apos;; &#125;, 1000);&#125;, false); 和Web端的同学一开始怎么也搞不定点击按钮跳转，找了好久终于发现为了提高手机端Web页面的点击响应速度，我们的Web端默认是使用touch事件来代替click的，但是在Universal Links的跳转中必须使用click。另外，页面初始页和要跳转的页的域名必须是不同的，否则这个跳转事件也不会调起对应的App！另外，在进行Universal Links的调试时，建议先删除App，然后重新编译，运行。 总结稍稍总结一下，Universal Links的工作原理大体上就是，App第一次启动后，发现自己是支持Associated Domains的，就去Associated Domains中描述的域名的根目录去下载一个名叫apple-app-site-association的文件，之后系统运行的Safari，其他应用的SFSafariViewController, WKWebView, 或者UIWebView都会受到这个apple-app-site-association文件的影响，在用户点击那个跳转的链接时，系统就会启动对应的App。不得不说，以后每个版本的What’s New还是必须得看得更加仔细一些，同时需要大大提高对于新技术的敏感度。最后的最后，再次感慨一下腾讯确实强大，但是还是苹果爸爸更屌！]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小谈Protocol-Oriented Programming in Swift]]></title>
    <url>%2F2016%2F01%2F21%2F%E5%B0%8F%E8%B0%88Protocol-Oriented-Programming-in-Swift%2F</url>
    <content type="text"><![CDATA[前言最近和老刘约好希望能够每周能够在这里留下点什么，往日的鸽王老刘上周竟然没有鸽！反倒是我周末因为忘带电脑，导致无力一更，这周又天天加班到爆炸，竟然拖了大半周，趁着明天公司要开拔去开年会，今天早早溜了回来，想着不能再欠着了，今日就把这一更搞定吧~ 小割一发 今天就就着WWDC的Protocol-Oriented Programming in Swift来小谈一记。说到Protocol-Oriented Programming，就不得不提到与它对应的Class-Oriented Programming（又或者说Object-oriented programming），想到当年刚刚接触C++的时候，博主就对C++中的Class表示了赞叹，可以把一个个对象抽象出来，把一些方法封装起来，可以非常方便而且结构清晰地解决问题，重点是OOP，听起来就屌屌的啊，绝对的装逼一大利器。首先，我们来看看在传统OC上的Class都能够帮我做些什么 Encapsulation：封装显然不必多说，Class最最基本的属性就是封装了。Access Control：这也不必多提，就像平时开车的时候踩了刹车，刹车灯就亮了一样，显然造汽车的时候给踩刹车这件行为加上了Setter方法，当刹车状态发生变化的时候，就顺便把刹车灯的状态也做了改变。Abstraction：抽象自然也不需要多提，Class本身就是用来定义一件事物的抽象特点的。Namespace：这点主要是用来解决命名冲突，例如ClassA可以定义一个叫sort的方法，ClassB也可以定义自己的sort方法。Expressive Syntax：这点我偷偷地认为大约就是用Class来封装一些实体的对象，能够让后续代码的可维护性提高，更加便于使用人类可以理解的语法来表达一些行为。例如：定义了一个Person对象，那么这个对象的name，age等等属性就非常顺理成章了，同时eat，sleep这些方法在我们的语法中也就很正常了。Extensibility：在OC中对于Class的扩展还是非常方便和实用了，可以subclass，可以category，也可以extension等等。当然，以上提到的种种到了Swift中之后就不再是Class的特权了，在Swift中，Struct甚至是Enum都可以轻松拥有上述的能力。 于是乎，似乎在Swift中，Class留下的唯一优势就是Inheritance了，抽象好父类，然后子类再进行继承，父类可以定义一些通用的方法，如果子类不需要做特殊的事情，直接就可以不用管，如果子类要做的事情和父类不一样，那么将这些不一样的点单独再抽象出来，子类override就可以了，这样解决起问题来，简明而且优雅，简直不能更赞！ 但是继承在给我们带来便利的同时，也不是完全没有开销的，我们先撇开那些因为水平不够而做出不合理的封装和继承不谈，哪怕是经过良好思考和设计的继承也不得不面对一些问题，其中一个问题便是Implicit Sharing，在日常实践中，在一个Class中保存一些数据必然是无法避免的，同时，如果做了继承，就很难避免子类本身是不需要完全继承父类的所有数据这个问题，往往都是子类中包含了很多本身完全用不到，但是却又不得不从父类继承而来的数据指针，OC为了性能的考虑对于这部分共享的数据是通过Implicit Sharing也就是隐式共享来实现的，也就是说子类本身不会再去拥有一份这些数据，而是通过隐式共享来共用父类的，但是一旦出现了共享，就势必会出现竞争，一旦出现竞争，为了保证数据的安全，就不得不再引入lock，一旦引入了lock，又势必会降低性能，甚至出现是死锁的情况。以至于Apple在他的官方开发文档中都做出了如下的声明 It is not safe to modify a mutable collection while enumerating through it. Some enumerators may currently allow enumeration of a collection that is modified, but this behavior is not guaranteed to be supported in the future 另外，继承还有另外的一个问题，那就是一个儿子只能有一个老子——子类不可以从多个父类继承。同时，子类与父类的继承关系只能在子类被设计的时候就定义好，也就是儿子在出生的时候就确定了自己的唯一亲身父亲，是不可以再以后的成长过程中再去认个老子当自己的亲身老爹！那么，子类在后续开发过程中无论怎么扩展，都无法改变继承关系，不能引入更多抽象封装，除非对父类进行修改，但是一旦我们没有父类的源代码，那就只能蒙逼了！ 再然后，在子类中Override父类的的一些方法的时候也必须小心翼翼，否则非常容易导致父类的业务逻辑链发生断裂，导致整个业务无法正常完成，甚至于，在子类中很难去判断，哪些方法是可以重写的，哪些方法是不能重写的。 还有一点，在Swift中，因为继承带来的多态会导致编译器类型检查出现Error，例如： 12345678910class Orderd &#123; func precedes(other: Orderd) -&gt; Bool &#123; fatalError(&quot;implement me!&quot;)&#125;&#125;class Number : Orderd &#123; var value: Double = 0 override func precedes(other: Orderd) -&gt; Bool &#123; return value &lt; other.value &#125;&#125; 其中， return value &lt; other.value编译器就一定会报错，为了解决这个Error，我们只能将代码改成 12345678910class Orderd &#123; func precedes(other: Orderd) -&gt; Bool &#123; fatalError(&quot;implement me!&quot;)&#125;&#125;class Number : Orderd &#123; var value: Double = 0 override func precedes(other: Orderd) -&gt; Bool &#123; return value &lt; (other as! Number).value &#125;&#125; 但是显然这种强转是不安全的，因为谁也不知道Order又会被其他那个阿猫阿狗给继承，而那个类中又是否有value这个属性。 好了，给继承挑了这么多毛病，我们该谈谈Swift中的Protocol-Oriented Programming了。 首先，在Swift中，当你需要去抽象对象的时候，第一反映不应该想到Class，而是应该想到Protocol。对于上面提到的例子，如果我们使用Protocol来实现的话，就会变成这样： 12345678910protocol Orderd &#123; func precedes(other: Self) -&gt; Bool&#125;struct Number : Orderd &#123; var value: Double = 0 func precedes(other: Number) -&gt; Bool &#123; return value &lt; other.value &#125;&#125; 而这个Protocol就会变成这样： 12345678910func binarySearch(sortedKeys:[T], forKey k: T) -&gt; Int &#123; var lo = 0 var hi = sortedKeys.count while hi &gt; lo &#123; let mid = lo + (hi - lo) / 2 if sortedKeys[mid].precedes(k) &#123; lo = mid + 1 &#125; else &#123;hi = mid&#125; &#125; return lo&#125; 后记好吧，其中本文主要都在介绍继承的side effect，并没有太多提到Protocol-Oriented Programming的优点，不过，Protocol-Oriented Programming没有上面提到的那些缺点应该就可以算是它的优点了吧^_^，下面附上WWDC2015年的视频链接，有兴趣的可以自己再去看看。https://developer.apple.com/videos/play/wwdc2015-408/ 最后的最后在研究OOP的缺点的时候，看到了一个专业术语，叫做内存墙，有兴趣的同学可以自己点链接去看。下面附上一张图片来说明内存的进步速度是远远比不上CPU的，而OOP的语言在最初设计的时候并没有考虑到这个问题，可能会导致在内存的使用上并不能达到机器的最大性能，而导致性能有所削减，具体的就不再展开，有兴趣的可以去知乎上看看这个哥们的帖子：面向对象编程的弊端是什么？-Milo Yip的回答]]></content>
      <tags>
        <tag>iOS开发</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于大数据去重的两三事]]></title>
    <url>%2F2016%2F01%2F13%2F%E5%85%B3%E4%BA%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D%E7%9A%84%E4%B8%A4%E4%B8%89%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[P.S. 下文提到的数据基于iPhone 6S， iOS9.2（12C75） OK, 转入正题，最近博主在公司里接到一个任务，需要在一个大约4万条数据的数据库中快速将数据Fetch出来，载入内存之中，然后根据这些数据的某一个字段进行快速排重检查，并把重复的对象进行分组显示。 接到这个任务，博主的第一反应就是把所有数据都取出来，然后把需要进行去重排序的那个值作为NSDictionary的Key，然后将那些对象组成一个Array，作为这个Key的Value，大致的代码如下： 12345678910111213NSMutableDictionary *result = [[NSMutableDictionary alloc] init];NSMutableArray *allData = [self allData];for (Object *object in allData)&#123; NSMutableArray *oneGroupObjects = result[object.someKey]; if (oneGroupObjects == nil) &#123; oneGroupObjects = [[NSMutableArray alloc] init]; &#125; [oneGroupObjects addObject:object]; [result setObject:oneGroupObjects forKey:object.someKey];&#125; OK, 搞定！ 编译，安装，走你！ 一看时间3s多一点点, 博主认为这个时间还算可以接受，毕竟在手机上，毕竟4万多条数据呢。 可是博主的Boss们可不这么认为，才4万多条数据，竟然就要话这么长时间！ 没办法，改吧~ 中间复杂的过程就不多赘述了，说说最后的结果吧。 首先，还是用CoreData把所有数据取出来，然后丢到一个容器里，丢容器里的原因一个是为了后续的遍历，另一个原因就是为了保证这些对象不会被ARC给自动释放了，为什么不能被释放？我们下面再说。接着遍历这些取出来的数据，然后将数据组装到C语言的struct中，将这个这个对象的内存地址作为这个struct的ID。然后将需要排序的值做一次快排，然后就能够根据顺序，将相同的组分出来了。然后，就是将C的struct中的那个ID对象再转回CoreData对象，对！这就是为什么那些CoreData对象不能被自动释放的原因，这个内存地址是作为链接C语言算法和NSManagedObject对象的桥梁！具体回转的代码如下： 12void *p = (void *)( *oneResult);NSManagedObject *obj = (__bridge NSManagedObject *)p; OK，搞定！再走你！0.4s，是不是非常炫！ 总结：Apple提供的各种容器提供了非常方便的各种方法，但是这些封装也是以性能损失为代价的，所以在处理非常大量的数据的时候还是应该对于特殊的情况，进行特殊处理。]]></content>
      <tags>
        <tag>iOS技巧</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用一个数组过滤另一个数组]]></title>
    <url>%2F2016%2F01%2F13%2F%E4%BD%BF%E7%94%A8%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E8%BF%87%E6%BB%A4%E5%8F%A6%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[话不多说，直接上代码： 123456789101112131415161718192021222324252627282930313233343536NSMutableArray *resultArray = [[NSMutableArray alloc] init];NSArray *array = @[@&quot;a&quot;,@&quot;a&quot;,@&quot;c&quot;,@&quot;d&quot;,@&quot;e&quot;,@&quot;f&quot;,@&quot;g&quot;,@&quot;h&quot;];NSArray *secondArray = @[@&quot;a&quot;, @&quot;c&quot;, @&quot;f&quot;];int j = 0;for (int i = 0; i &lt; [array count]; ++i)&#123; NSString *firstString = array[i]; NSString *secondString = secondArray[j]; if ([firstString isEqualToString:secondString]) &#123; [resultArray addObject:firstString]; &#125; else if ([firstString compare:secondString] == NSOrderedDescending) &#123; if (j == [secondArray count] - 1) &#123; break; &#125; for (int k = j + 1; k &lt; [secondArray count]; ++k) &#123; secondString = secondArray[k]; if ([firstString isEqualToString:secondString]) &#123; j = k; [resultArray addObject:firstString]; break; &#125; else if([firstString compare:secondString] == NSOrderedAscending) &#123; j = k; break; &#125; j = k; &#125; &#125;&#125;NSLog(@&quot;%@&quot;, resultArray); 我们来看看算法的复杂度： 如果做两个数组的遍历，显然算法复杂度为：O(m * n) 使用上述的办法需要先将两个数组进行排序（假设使用快排），因此算法的复杂度为：O(n(logn + n) + m(logm + m)) = O(nlogn + mlogm)]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2015%2F12%2F24%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[UITableView长按显示菜单的实现]]></title>
    <url>%2F2015%2F12%2F14%2FUITableView%E9%95%BF%E6%8C%89%E6%98%BE%E7%A4%BA%E8%8F%9C%E5%8D%95%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[作为一个“资深”iOS开发程序猿，当然不能只是用这么个地方来低吟浅唱，无病呻吟了。这篇文章就作为技术博客的开篇吧。 P.S. 其实本文的内容毫无技术含量，权当用来年纪渐长，记忆渐衰的提醒了。 我是“有技术”的分割线 这次要实现的东西非常简单，就是希望能在tableView的Cell上长按，然后出现菜单，然后点击进行相应的操作。最直接的实现方式就是在Cell上加一个LongPress的Gesture，捕获到LongPress的手势之后用UIMenuController把菜单显示出来。如果你已经能想到这些，那么恭喜你，你的战斗力已经很强了，至少已经学会使用Gesture，在Cell上算出Menu需要显示的区域，使用delegate，block或者notification甚至更加高深的机制如AssociatedObject通知另一个对象。但是博主比较懒，以上说的这些都不想自己做，特别是加Gesture，算区域等等，于是才有了下面这些哔了狗的内容。 首先，我们发现UITableView提供三个非常牛逼的Delegate方法 123optional public func tableView(tableView: UITableView, shouldShowMenuForRowAtIndexPath indexPath: NSIndexPath) -&gt; Booloptional public func tableView(tableView: UITableView, canPerformAction action: Selector, forRowAtIndexPath indexPath: NSIndexPath, withSender sender: AnyObject?) -&gt; Booloptional public func tableView(tableView: UITableView, performAction action: Selector, forRowAtIndexPath indexPath: NSIndexPath, withSender sender: AnyObject?) 下面开始哔狗第一式这三个delegate方法只要有一个方法你没有实现，那么tableView都会华丽地无视你的长按事件，比如你只实现了其中的两个，没有实现第三个，那么恭喜你，你实现的那两个哥们会因为你无视了他们第三个兄弟而永远都不再理你。 OK，我按照要求把这三兄弟都实现了，shouldShowMenuForRowAtIndexPath返回了true，canPerformAction也返回了true，启动程序，长按Cell，是不是可以看到Menu了，点击弹出的Menu，performAction那个delegate是不是也被调用了！欣喜若狂有没有？！恭喜你，你可以进入哔狗第二式了，为何？因为他喵的显示了好多我不要的action啊！咦？不是有canPerformAction么，在这个delegate里面判断一下不就OK了么，英雄所见略同啊！博主也是这么想的，因为我只需要delete：这个方法，所以我只有当action == “delete:”的时候才返回了true，其他的都返回了false，OK，启动程序，长按，然后……然后就没有然后了？！毛都没显示出来啊！我感觉一定是我的打开方式有什么问题，于是去google了许久，StackOverFlow了许久，找到了一坨看似很有道理，实际上毛用都没有的答案，比如：这个TableView不能放在UIViewController里的啊，一定要放在UITableViewController里呢；哎呀~不要用这种方式实现啦，自己去加LongPress喽等等等等，这也促使博主怀着澎湃的心情，写下这篇“技术”帖。 哔狗第二式打坐苦思冥想许久，博主尝试性地在cell中override了canPerformAction 1234567override func canPerformAction(action: Selector, withSender sender: AnyObject?) -&gt; Bool &#123;if action == &quot;delete:&quot; &#123; return true&#125; else &#123; return false &#125;&#125; 启动程序，长按，只显示了一个Delete按钮，炫！点击，Duang！程序华丽Crash！unrecognized selector sent to instance！ 哔狗第三式为何ViewController里的performAction delegate不起作用了！也是，canPerformAction是在Cell里实现的，ViewController能知道个毛，于是，只能在cell里再实现override func delete(sender: AnyObject?)，启动程序，长按，终于成了！ 再割一条 其实上面的全是废话，你只需要看下面的内容哦，亲~ 在VC里实现tableView的那三个delegate，一个都不能少哦~在cell里override canPerformAction，在你需要的action中返回true在cell里实现你对应的action，然后通知VC，哪个action被点击了如果把所有内容全看完的，请不要骂我~ 后记写完这篇毫无技术含量的“技术”帖，我还是觉得我打开方式可能不对，感觉应该不需要使用这种“非主流”的方式实现这个需求，今天先这么不知甚解一把吧，等后面空下来再去细究一下~（其实我知道估计不会再去细究了~）]]></content>
      <tags>
        <tag>iOS开发</tag>
      </tags>
  </entry>
</search>
